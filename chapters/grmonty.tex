\chapter{Grmonty: Monte Carlo para Relatividade Geral}
\label{cap:grmonty}

\section{O que é o GRmonty}
  Dolence et al definem o \textbf{grmonty} como ``software destinado a calcular o espectro de plasmas quentes e opticamente finos levando em consideração a relatividade geral por completo, utilizando um código de transporte radioativo baseado na técnica de Monte Carlo''\citep[p.1, traduzido]{Dolence:09}. Em outras palavras o programa estima o espectro de uma simulação de magnetoidrodinâmica \cite{eletro-hidro-dynamic:42} relativística utilizando o método de Monte Carlo.

  Buracos negros são regiões no espaço-tempo que possuem uma gravidade tão grande, que a velocidade de escape nestas áreas é maior que a velocidade da luz, assim nada é capaz de escapar deste local. Uma vez que algo adentra é impossível que saia \cite{fatalgravity:10}.

  Existem diferentes categorias de buracos negros, podemos diferenciá-los de acordo com a sua massa. Existem os buracos negros estelares que são restos de estrelas, e os super massivos que habitam o núcleo de galáxias. Quando uma estrela com mais de 25 vezes a massa do Sol, isto é, 25 massas solares torna-se uma supernova, o resto de seu núcleo pode se tornar um buraco negro estelar. Fortes evidências apontam que Cygnus X-1 com aproximadamente $14.8$ massas solares é um buraco negro desse tipo \cite{cygx1:11}.

  No centro de nossa galáxia evidências apontam a existência de um buraco negro super massivo Srg A*, com massa estimada em $4 \cdot 10^6$ massa solares \cite{2016ApJ...830...17B}, ou seja, sua massa é milhões de vezes maior que a do sol. Muito provavelmente sua formação não advém de uma supernova e sim da fusão de vários buracos negros \cite{fatalgravity:10}.

  Buracos negros são geralmente rodeados por um gás composto de partículas carregadas, plasma. Este gás está em rotação ao redor do buraco formando um disco de acreção. Este plasma está submetido a gigantescas acelerações, sofrendo fricção, sendo comprimido e aquecido a temperaturas entre $10^4k$ e $10^{12}k$. Devido a estas altas temperaturas, este plasma emite radiação em um amplo intervalo de comprimentos de ondas, do rádio a raios gama \cite{1969Natur.223..690L}.
  
  Modelar e simular o espectro de radiação eletromagnética, gerado por estes discos de acreção tem sem mostrado um grande desafio. Este é o problema que o \textbf{gmronty} se propõem a resolver.

  Quando é dito que o programa leva em consideração toda a relatividade geral, significa que todos os efeitos do espaço-tempo curvo, da relatividade geral de Einstein, são levados em conta na absorção, emissão e espalhamento dos fótons. Criando assim um  espectro final mais detalhado e rico  \cite{Dolence:09}

  Utilizando o método de Monte Carlo na geração de fótons, e a partir de um dado modelo de plasma fornecendo a velocidade, densidade, intensidade do campo magnético e temperatura, o programa busca gerar um espectro da radiação emitida. Para tanto um número próximo a \textit{N} - fornecido na entrada - de fótons é gerado e para cada um sua trajetória é traçada. Nesse percurso o fóton é espalhado podendo passar por diversas interações, até finalmente ser mensurado.

  Depois de algumas iterações um número próximo a \textit{N} de fótons já foi gerado e rastreado, desta forma um relatório com o espectro é obtido e retornado pelo programa que finalmente termina.

  O objetivo do \textbf{grmonty} é quantificar  o espectro eletromagnético de plasma ao redor de buracos negros, como função das condições do gás (velocidade, densidade,  intensidade do campo magnético e temperatura) e das propriedades do buraco negro, massa, momento angular e carga elétrica \cite{Dolence:09}.


\section{Como o programa funciona}
\label{sec:comofaz}

  No momento de criação e rastreio dos fótons o programa faz uso da biblioteca \textbf{OpenMP} para paralelizar o seu desenvolvimento. Graças a esta abordagem é viável o potencial aproveitamento de todos os núcleos disponíveis na CPU da máquina. A biblioteca é utilizada para que cada fóton seja produzido e espalhado de forma independente dos outros e funcionando em paralelo. Isso só é possível por que, as instruções não dependem de cada fóton, elas são as mesmas para todos. Assim, podemos caracterizar o \textbf{grmonty} como tendo uma computação SIMD.

  ``Única Instrução Múltiplos Dados: Nesse tipo de computação podem existir múltiplos processadores, cada um operando sobre um item de dados, mas estão todos executando a mesma instrução naquele item de dados''\citep[p.84, traduzido]{HCP:16}. A arquitetura SIMD trabalha em ressonância com o OpenMP, uma vez que torna a paralelização factível e simples de ser aplicada.
  
  A parte do código que opera sobre os fótons apresenta características que facilitam a sua paralelização e portabilidade para uma arquitetura SIMD, como: não há escrita de variáveis compartilhadas entre os fótons, não há desvios de fluxo que tornem uma execução diferente das outras, não há necessidade de sincronização ou mutex (salvo no momento de incrementar o número total de fótons).
  
  Também existem alguns desafios à aplicação de paralelização. Os dados que representam as condições iniciais do plasma são compartilhados por todos os fótons. São variáveis globais acessadas por referência. Há condicionais que podem tornar alguma execução em particular mais longa, segurando o progresso das outras que estão na mesma unidade de processamento (caso das GPUs)

  Toda a vez que um fóton é criado logo em seguida sua rota é traçada, a relação entre criação e cálculo de trajetória é de 1 para 1, ou seja, não há criação de um conjuto de $n$ fótons que depois teriam seu caminho rastreado, tornando a relação $n$ para $n$. Isto agrupa funções muito diferentes, que acessam e dependem de variavéis e funções distinjas, juntas. Acarrentando em uma maior dependencia a dados, que podem estar mais distantes indo contra o princípio da localidade, provocando uma possível perda de performance.
  
  Esta relação é percebida ao se observar as linhas 106 a 137 do \textit{grmonty.c}, aqui copiadas:

  \label{sec:main_loop}
  \begin{lstlisting}
    #pragma omp parallel private(ph)
  	{
  		while (1) {
  			/* get pseudo-quanta */
    #pragma omp critical (MAKE_SPHOT)
  		  {
  				if (!quit_flag)
  					make_super_photon(&ph, &quit_flag);
  			}
  			if (quit_flag)
  				break;

  			/* push them around */
  			track_super_photon(&ph);

  			/* step */
    #pragma omp atomic
  			N_superph_made += 1;
        /*mais codigo*/
  		}
  	}
  \end{lstlisting}

  Fica claro também - ao observar a linha 8 a 14 - que o processamento do rastreio é feito assim que possível, ao oposto de um processamento em lotes, ou seja, assim que o comandado \textit{make\_super\_photon} é executado, gerando um novo fóton \textit{ph}, o  \textit{track\_super\_photon} é chamado, não havendo algum buffer ou lote, um fóton produzido é um fóton consumido.

  Tal processamento reduz muito os vestígios que um fóton pode criar durante sua existência. Uma vez que não se perde tempo deixando-o na memória, assim que é mensurado seu espaço na memória já é ocupado pelo próximo fóton a ser produzido, há um foco na economia de memória. O número de fótons na memória é o número de threads rodando simultaneamente.

  Por fim se faz necessário notar que o programa é escrito na linguagem de programação C. O que faz muito sentido do ponto de vista de performance, uma vez que C é uma linguagem de baixo nível, mais próxima a linguagem de máquina e por isso é quase sempre explícito a quantidade e de que forma se está manipulando a memória. Outras vantagens são as possibilidades de usar tanto a biblioteca \textbf{OpenMP} como as otimizações do \textbf{gcc}, o \textit{Gnu C Compiler}, mas do ponto de vista da expressividade uma linguagem de mais alto nível poderia apresentar outras vantagens, como uma maior legibilidade do código e o uso de abstrações e encapsulamento, aumentando também a capacidade e a facilidade de fazer manutenções e melhorias no código.
